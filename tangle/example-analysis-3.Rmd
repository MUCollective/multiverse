---
title: "temp"
author: "Abhraneel Sarma"
date: "2/19/2022"
output:
  html_document:
    css: ../inst/css/styles.css
  pdf_document: default
---

```{r setup} 
library(dplyr)
library(tidyr)
library(purrr)
devtools::load_all(".")

knit_as_emar()
```


## Multiverse case study #4

```{r}
data("hurricane")

hurricane_data <- hurricane %>%
    # rename some variables
    rename(
        year = Year,
        name = Name,
        dam = NDAM,
        death = alldeaths,
        female = Gender_MF,
        masfem = MasFem,
        category = Category,
        pressure = Minpressure_Updated_2014,
        wind = HighestWindSpeed
    ) %>%
    # create new variables
    mutate(
        post = ifelse(year>1979, 1, 0),
        zcat = as.numeric(scale(category)),
        zpressure = -scale(pressure),
        zwind = as.numeric(scale(wind)),
        z3 = as.numeric((zpressure + zcat + zwind) / 3)
    )
```


## Multiverse Analysis

To implement a multiverse analysis, we first need to create the `js parameter('masfem')` object <damage_transform/>:

```{r}
M = multiverse()
```

```{multiverse default-m-1, inside = M}
# here we just create the variable `df` in the multiverse
df = hurricane_data

# here, we perform a `filter` operation in the multiverse
df.filtered = df %>%
  filter(branch(death_outliers,
      "no_exclusion" ~ TRUE,
      "most_extreme" ~ name != "Katrina",
      "two_most_extreme" ~ !(name %in% c("Katrina", "Audrey"))
))
```

```{multiverse label = variable_definitions, inside = M}
df.filtered = df.filtered %>%
    mutate(
        femininity = branch(femininity_calculation,
          "masfem" ~ masfem,
          "female" ~ female
        ),
        damage = branch(damage_transform,
          "no_transform" ~ identity(dam),
          "log_transform" ~ log(dam)
        )
    )
```


```{multiverse default-m-2, inside = M}
mean(df.filtered$femininity)
```


```{multiverse default-m-3, inside = M}
hist(df.filtered$femininity)
hist(df.filtered$damage)
head(df.filtered)
```


```{multiverse default-m-4, inside = M}
fit <- glm(death ~ masfem * dam + masfem * zpressure, data = df, family = "poisson")

fit.summary = broom::tidy(fit)
```


```{r}
expand(M)
```


```{r}
# don't need this when compiling as package compiles everything
# execute_multiverse(M)
```


```{r, eval = FALSE}
extract_results_json = function (multiverse, summary_obj, filename) {
  if (!is.multiverse(multiverse)) stop(deparse(multiverse), " needs to be an object of class multiverse")
  
  summary_obj = as_name(enquo(summary_obj))
  .summary_obj_default = extract_variable_from_universe(multiverse, 1, summary_obj)
  
  if (!tibble::is_tibble(.summary_obj_default)) stop(summary_obj, " declared inside the multiverse analysis needs to be an object of class tibble or data.frame; please create ", summary_obj, " using broom::tidy or an analogous function")
  
  if (!all(c("term", "estimate", "std.error") %in% names(.summary_obj_default))) stop(summary_obj, " declared inside the multiverse analysis needs to contain the following columns: `term`, `estimate` and `std.error`")
  
  ## ISSUE: if the summary_obj has a distributional object
  
  expand(multiverse) %>%
    extract_variables(!!sym(summary_obj)) %>%
    select(-.code, -.results, -.errors) %>%
    rename(results = summary_obj) %>%
    unnest(results) %>%
    mutate(
      # do we want to perform any text processing on the output of broom::tidy?
      # I think we want the user to do these modifications instead of trying to do this on our own??
      # term = ifelse(term == "(Intercept)", 'Intercept', term)
      min = estimate - 5*std.error,
      max = estimate + 5*std.error
    ) %>%
    group_by(term) %>%
    mutate(min = min(min), max = max(max)) %>%
    mutate(
    cdf.x = pmap(list(min, max, estimate, std.error), ~ seq(..1, ..2, length.out = 101)),
    cdf.y = pmap(list(cdf.x, estimate, std.error), ~ pnorm(..1, ..2, ..3))
    ) %>%
    nest(results = c(term:cdf.y)) %>%
    jsonlite::write_json(filename, pretty = TRUE)
}

extract_results_json(M, fit.summary, 'data2.json')
```




